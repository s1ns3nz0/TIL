# Cloud Native Spring in Action
## 1. Cloud Native Fundamentals
### 1.5) 클라우드가 최선의 선택인가?
- 클라우드 네이티브를 통해 해결하려는 문제점을 가지고 있지 않고 그러한 속성이 필요 없다면 클라우드 네이티브는 최적의 방안이 아닐 수도 있다.
- 특정 기술이나 접근 방식이 문제를 해결할 수 있는 지 파악하는 것이 핵심이다.
- 클라우드 네이티브로 가기 위한 주요 목표는 속도, 확장성, 복원력 및 비용이다.
- 속도(더 빠르고 유연한 배포), 복원력(가용성 및 안정성), 확장성(탄력성 및 동적 확장성), 비용(효율성 및 비용 최적화)
#### 1.5.1) 속도
- 더 신속하게 그리고 더 빈번히 출시하는 것은 경쟁과 고객 마감일 뿐만 아니라, 피드백 주기를 더 짧게 만든다.
- 피드백 루프가 짧아지면 새로운 기능과 관련된 위험이 감소한다.
#### 1.5.2) 복원력
- 클라우드 네이티브 애플리케이션은 복원력이 높아야 하는데 클라우드 기술을 통해 복원력이 높은 인프라를 구현하기 위한 전략을 세울 수 있다.
- 항상 사용 가능하고 안정적이며 복원력이 높아야 하는 것이 비즈니스의 요구 사항이라면 클라우드 네이티브는 좋은 선택이 될 수 있다.
#### 1.5.3) 확장성
- 탄력성은 부하에 따라 소프트웨어를 확장할 수 있다는 것을 의미한다.
- 상황에 따라 동적으로 확장할 수 있어야 한다.
- 새로운 고객에게 신속하고 효율적으로 적응해야 하거나 새로운 유형의 클라이언트를 지원할 수 있는 유연성이 필요한 비즈니스라면, 확장성 높은 클라우드 네이티브 애플리케이션을 클라우드와 결합해 사용한다면 필요한 탄력성을 확보할 수 있다.
#### 1.5.4) 비용
- 24시간 내내 실행되는 인프라는 더 이상 필요 없다.
- 필요한 자원만을 생성해 실제 사용한 만큼 지불하고, 더 이상 필요없는 자원은 회수한다.
### 1.6) 클라우드 네이티브 구성
- 특정 기술이나 아키텍처를 언급하고 있긴 하지만, 단지 예시임
#### 1.6.1) 컨테이너
- 컨테이너 이전에는 환경 재구축, 격리 및 설정을 위해 가상 컴퓨터에 의존했다.
- OS 컨테이너는 내부에서 애플리케이션을 실행하기 위해 필요한 모든 것을 가지고 있는 경량 실행 파일 패키지이다.
- 컨테이너는 호스트와 커널을 공유한다.
- 리눅스에서는 리눅스 커널이 제공하는 몇 가지 기능을 활용하면 가능하다.
  + 네임스페이스(namespace): 각 프로세스(또는 프로세스 그룹)가 시스템에서 사용할 수 있는 리소스를 일부만 볼 수 있도록 하기 위해 프로세스 간 리소스를 분할
  + C그룹(cgroup): 프로세스에 대한 리소스 사용을 제어하고 제한
- 컨테이너는 애플리케이션이나 의존 라이브러리 혹은 미들웨어와 관계 없이 거의 모든 컴퓨팅 환경에서 안정적으로 실행할 수 있다.
#### 1.6.2) 오케스트레이션
- 단일 서버에서 컨테이너를 생성하고 관리하는 것은 간단하지만 수십 또는 수백 개의 컨테이너를 여러 대의 서버에 배포하고 처리하려면 또 다른 무엇인가가 필요하다.
- 컨테이너 오케스트레이션은 다음과 같은 다양한 작업을 자동화하는 데 도움이 된다.
  + 클러스터 관리로서 필요한 경우 머신을 생성하거나 삭제할 수 있다.
  + 컨테이너가 서로 통신하도록 네트워크를 설정하고 라우팅, 서비스 검색 및 로드 밸런싱을 정의한다.
  + 인터넷에 서비스 노출, 포트 및 네트워크를 구축한다.
  + 특정 기준에 따라 컨테이너에 자원을 할당한다.
  + 보안 및 액세스 제어 정책을 시행한다.
- 오케스트레이션 튤에 대한 명령은 선언적으로 이루어지는데, YAML 파일을 통해 수행된다.
- 보통은 특정 툴이 원하는 형식과 언어를 사용해 달성하고자 하는 상태를 기술한다.
#### 1.6.3) 서버리스
- 클라우드 서비스가 제공하는 추상화 계층을 한층 더 늘려 서버리스 기술을 사용할 수 있다.
- 개발자는 애플리케이션에 대한 비즈니스 로직을 구현하는 데만 집중할 수 있다.
- 서버리스 플랫폼은 가상 시스템, 컨테이너 및 동적 확장을 포함하여 실행할 애플리케이션에 필요한 모든 인프라 작업을 플랫폼이 대신 처리해준다.
- 서비스형 백엔드(Backend as a service, BaaS)
  + 클라우드 공급자가 제공하는 타사 서비스에 크게 의존하는 애플리케이션을 의미하며, 데이터베이스, 인증 서비스, 메시지 큐와 같은 것들이 해당
  + 옥타, 구글 파이어베이스, 아마존 API Gateway
- 서비스형 함수(Function as a service, FaaS)
  + 상태가 없고 이벤트에 의해 실행되며 플랫폼이 전적으로 관리하는 애플리케이션을 의미한다.
  + 애플리케이션의 오케스트레이션 및 확장과 관련된 배포 및 운영 비용을 줄이는 데 중점을 둔다.
  + 아마존 람다, 구글 클라우드 함수, 케이네이티브, 아파치 오픈휘스크
  + 서버리스 모델에서는 필요한 경우에만 리소스가 제공되며 처리할 것이 없으면 모든 것이 중단된다. 이것이 바로 서버리스 플랫폼이 제공하는 주요 기능 중 하나인 제로 스케일링이다.
### 1.7) 클라우드 네이티브 애플리케이션을 위한 아키텍처
- 클라우드 네이티브 아키텍쳐 요소
  + 상호작용: HTTP, RSocket, gRPC 메시징과 같은 서비스 간 통신
  + 데이터 서비스: 데이터베이스, 메시징 시스템 및 상태를 유지하는 그 밖의 구성 요소
  + 애플리케이션 서비스: 느슨히 결합되고, 상태를 유지하지 않고 독립적으로 배포할 수 있는 단위
#### 1.7.2) 클라우드 네이티브 애플리케이션을 위한 서비스 기반 아키텍처
- 서비스: 다른 구성 요소에 어떤 종류의 서비스를 제공하는 구성 요소
  + 애플리케이션 서비스: 상태를 갖지 않으며 모든 종류의 논리를 구현한다.
  + 데이터 서비스: 상태 저장이 가능하며 모든 종류의 상태를 저장한다. 이 때 상태란, 서비스를 종료하고 새로운 인스턴스를 생성해야 할 경우 서비스 종료 전에 저장되어야 하는 모든 것이다.
- 상호작용: 시스템의 요구 사항을 충족시키기 위해 수행되는 서비스 간 통신
  + 
