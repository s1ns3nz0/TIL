# 시스템 이해
## 1. 프로세스/스레드/파일 디스크립터
### 1) 프로세스
- 실행 중인 프로그램의 인스턴스
- 각각의 독립된 메모리를 할당받는다.
- PID를 통해서 관리된다.
- 코드, 데이터, 힙, 스택 영역으로 이루어져있다.
### 2) 스레드
- 프로세스 내의 실행 단위
- 프로세스 내의 스레드들은 데이터와 힙 영역을 공유하지만 각각의 스택을 가지고 있다.
### 3) 파일 디스크립터
- 열린 파일을 나타내는 정수
- 0은 stdin, 1은 stdout, 2는 stderr를 의미한다.
## 2. 시스템 콜, 커널 영역, 유저 영역 흐름 이해
- 유저 영역의 프로그램이 라이브러리 함수를 호출한다.
- 해당 라이브러리 함수에 의해 시스템 콜을 발생시킨다.(소프트웨어 인터럽트)
- CPU가 유저 모드에서 커널 모드로 변경된다.
- 커널이 해당 요청을 처리한다.
- 처리 결과를 유저 공간으로 복사한다.
- CPU가 유저 모드로 변경된다.
- 시스템콜 리턴값을 프로그램에게 반환한다.
## 3. 메모리 구조
### 1) 힙
- 동적 할당 메모리가 할당되며, 낮은 주소에서 높은 주소로 자란다.
- 프로그래머가 명시적으로 관리해야 한다.
### 2) 스택
- 지역 변수, 함수 호출 정보가 저장되며, 높은 주소에서 낮은 주소로 자란다.
- 컴파일 타임에 크기가 결정되고 자동적으로 관리된다.
### 3) 페이지 캐시
- 커널이 관리하는 디스크 입출력 캐시
- 파일 읽기/쓰기 능력을 향상 시키기 위해 자주 접근하는 블록을 메모리에 캐싱한다.
- free 명령어 결과에서 cached로 표시되며, 필요시 애플리케이션에 반환될 수 있다.
# 네트워크 이해
## 1. TCP Handshake
### 1) 3-Way Handshake
- 클라이언트가 서버로 SYN 패킷(x) 전송
- 서버가 클라이언트로 SYN(y), ACK 패킷(x+1) 전송
- 클라이언트가 서버로 ACK 패킷(y+1) 전송
### 2) 4-Way Handshake
- 클라이언트가 서버로 FIN 패킷 전송
- 서버가 클라이언트로 ACK 패킷 전송(서버가 확인)
- 서버가 클라이언트로 FIN 패킷 전송(서버가 종료 준비 완료)
- 클라이언트가 ACK 패킷 전송(완전 종료)
## 2. 로드 밸런싱
### 1) L4 로드 밸런싱
- IP, 포트 번호 기반으로 분산 수행
- TCP, UDP 헤더만 확인
- 빠르고 단순하지만 세밀한 제어가 불가능
- 예) 같은 IP:port로 온 요청을 여러 서버가 라운드 로빈으로 처리
### 2) L7 로드 밸런싱
- HTTP, 헤더, 쿠키, URL 기반으로 분산 수행
- 예) /api/*는 API 서버로, /static/*은 정적 파일 서버로 전달 가능
- SSL 종료 및 세션 영속성 지원
- 느리지만 유연함
## 3. DNS 리졸빙 흐름
- 브라우저가 영어로 된 사이트(www.example.com)를 요청
- 로컬 캐시 확인
- 없으면 ISP에서 제공하는 Recursive DNS 서버 질의
- Recursive 서버가 캐시 확인 후, 없다면
    + Root DNS 서버에서 확인 -> .com 주소 반환
    + .com TLD DNS에 질의 -> example.com 네임서버 주소 반환
    + Authorotive DNS에 질의 -> IP 주소 반환
- Recursive 서버가 해당 내용 캐싱 후, 클라이언트에 반환
- 브라우저가 해당 IP로 연결
# 애플리케이션 런타임 이해
## 1) 웹 서버
- HTTP 요청 처리 및 리벅스 프록시 기능 수행
- 정적인 컨텐츠 제공
- 빠르고 가볍지만 동적 컨텐츠 처리 불가
## 2) WAS 서버
- 무겁지만 동적 컨텐츠를 실행하여 비즈니스 로직 실행 가능
- 데이터베이스 연결 및 트랜잭션 관리
- 애플리케이션 코드 실행 환경 제공
## 3) Thread Pool 동작 원리
- 애플리케이션 시작 시 미리 N개의 스레드 생성
- 요청이 들어오면 대기 중인 스레드를 할당
- 작업 완료 후 스레드를 다시 풀에 반환
- 모든 스레드가 사용 중이면 요청을 큐에 대기
- 장점: 스레드 생성/삭제로 오버 헤드 제거, 리소스 제한으로 과부하 방지 가능
- 단점: 풀의 크기가 작으면 대기 시간이 증가하고 크면 컨텍스트 스위치 비용 증가
## 4) Connection Pool 사용 이유
- 미리 연결을 생성해 두고 재사용하는 방식
- 최대 연결 수 제어로 DB 과부하 방지 가능
- DB 연결은 비용이 큰 작업
    + TCP Handshake 수행
    + DB 인증 및 세션 초기화
- 매 요청마다 세션을 새로 연결한다면 응답 시간 및 DB의 부하 증가
## 5) GC와 메모리 누수
### GC(Garbage Collector)
- 더 이상 참조되지 않는 객체를 메모리에서 제거
### Memory Leak
- 더 이상 사용하지 않지만 참조가 남아있어 GC가 수거하지 못하는 상황
### 주요 원인
- Static 컬렉션에 객체를 계속 추가
- 리스너/콜백 등록 후 미 해제
- 커넥션/스트림 클로즈 누락
## 6) 트래픽 흐름
- 클라이언트(브라우저)
    + 사용자의 요청 발생(https://example.com/api/users)
    + DNS 리졸빙으로 IP 확인
    + 서버와 TCP/TLS Handshake
- 네트워크 계층
    + 라우팅을 통해 서버로 패킷 전달
- 로드 밸런서
    + Health check 결과, 살아있는 여러 서버 중 하나로 트래픽 분산
    + 필요 시 Session persistence
- 웹 서버
    + 정적 컨텐츠인 경우 직접 응답
    + 동적 컨텐츠인 경우 WAS로 proxy_pass
- WAS
    + Thread pool에서 work thread 할당
    + 요청 처리 실행
- 애플리케이션(Spring)
    + DispatchServlet이 요청 받음
    + Controller > Service > Repository 순으로 전달
    + Connection pool에서 DB 연결 획득
- 데이터베이스
    + SQL 실행
    + 인덱스 조회, 디스크 입출력 수행
    + 결과를 WAS로 반환
- 응답은 역순으로 진행됨
- 주요 병목 지점
    + DB 쿼리
    + 외부 API 호출
    + 쓰레드풀/커넥션 풀 고갈
    + GC pause
# 클라우드 환경 이해
## 1. VPC, Subnet, Security Group
### 1) VPC(Virtual Private Cloud)
- 논리적으로 격리된 가상 네트워크 공간
- 리전 단위로 생성되며, CIDR 블록으로 IP 범위 정의
### 2) Subnet
- VPC 내부를 더 작은 네트워크로 분할
- 가용영역 단위로 생성
- Public Subnet: Internet Gateway 연결, 공인 IP 할당
- Private Subnet: NAT Gateway를 통해서만 외부와 통신
### 3) Security Group
- 인스턴스 레벨의 가상 방화벽
- 인바운드, 아웃바운드 정책 정의
