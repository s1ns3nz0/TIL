# Cloud Native Spring in Action
## 2. Cloud Native pattern and technology
### 2.1) Cloud native development Principles: 12-Factor App and Beyond
- The Twelve-Factor App methodology for designing and building cloud native applications, proposed by Heroku cloud platform engineers
    + suitable for deployment on cloud platforms
    + Designed with scalability in mind
    + Applicable to various systems
    + supports continuous deployment and agility
- The Fiftenn-Factor App methodology presented in Kevin Hoffman's Beyond the Twelve-Facotr-App
##### 2.1.1) One codebase, One application
- Establishes a one-to-one relationship between the application and its codebase
- Shared code should be mained in a seperate codebase and support other applications either as a dependency library or as an independently executable service
- A Deployment is a ruuning instance of application, which can be deployed to different environments and the application artifacts excuted on each envrionment are identical
#### 2.1.2) API First
- Using an API First approach enables designing systems suitable for distributed architectures and distributing work accross different teams
#### 2.1.3) Dependency management
- All dependency libraries must be explicitly declared, enabling dependency library management tools to download them from a central repository
- The only dependencies application can implicitly assume will be available in its runtime envrionments are the language runtime and dependency management tools
#### 2.1.4) Design, Build, Release, Run
- Design: Determin the technologies, dependencies and tools required for specific application features
- Build: Compile the codebase and package it with dependency libraries to create an immutable artifact called build, which must be uniquely identifiable
- Release: Compile the build with environment specific configuration, Each release must be immutable and uniquely identifiable using versioning scheme such as semantic versioning or timestamps
- Run: Excute a specific release of the application in the runtime environment
#### 2.1.5) Configuration , credentials and Code
- Configuration refers to anything may vary between deployments. When configuration needs to change, it should be to do so without modifying code or rebuilding the application
- Examples include resource information for Backend services such as databases or messaging systems and credentials for accessing third-party APIs and feature flags.
#### 2.1.6) log
- Applications treat logs as time-ordered event streams and write them to standard output
- Logs can be collected and inspected using external tools such as log aggregators
#### 2.1.7) Disposability
- The case when applications can be initialized and stopped anytime refers this application is disposable
- When an application can be started or stopped at any time, It is referred to as "disposable"
#### 2.1.8) Backing Service
- Backing services can be defined as external resources that an application uses to provide its functionality
#### 2.1.9) Environment Parity
- Keep all environments as similar as possible
    + Time gap: Minimize the time between writing code and deploying to production through automation and continuous deployment
    + Personnel gap: Close the gap between developers who build applications and operators who manage production deployments by implementing the DevOps philosophy "You build it, You run it"
    + Tools gap: Use the same types and versions of backing services across all environments
#### 2.1.10) Admin processes
- Admin processes must be managed as code in version control system and excuted in the same runtime environment as the application they support
#### 2.1.11) Port binding
- Applications must be self-contained and expose services via port binding
- 애플리케이션이 제공하는 서비스는 포트 바인딩을 통해 외부로 노출된다.
- Services provided by applications are exposed externally via port binding
#### 2.1.12) Stateless processes
- Stateless applications delegate statem management and storage to backing services
#### 2.1.13) Concurrency
- When applications don't have state, Concurrenct process is possible
- Concurrent processing is only possbile when applications are stateless
- Applications must be able to serve many users through concurrency
#### 2.1.14) Telemetry
- All components provide the correct data to enable remote monitoring of system operations
- 애플리케이션을 우주 탐사선으로 비유하는 매우 매력적인 이미지를 통해 호프만은 중요성을 강조하고 있다.
- Hoffman emphasizes the importance through a compelling analogy that compares applications to spacecraft
- 원격으로 애플리케이션을 모니터링하고 제어하려면 어떤 종류의 원격 측정이 필요할까?
- What kind of telemetry is needed to remotely monitor and control applications?
#### 2.1.15) Authentication and Authorization
- Following the zero-trust approach, the security of interactions within the system must be ensured in all design and infrastructure levels
- Authentication enables tracking who is using the application
### 2.3) Application containerization via Docker
#### 2.3.1) Introduction to Docker: Images and Containers
- Docker server: The process that performs Docker's core operations
- Docker Daemon: Runs in the background and create and manage docker objects such as images, containers, volumes and networks
- Docker host: The computer on which docker server runs
- Docker client: The Interface that interacts with the API provided by the docker daemon
- Container Repository: Services that store and share container images
- Container image: A lightweight excutable package that includes everything needed to run applications
- Container: A running instance of a container image
#### 2.4.1) Introduction to Kubernetes: Deployments, Pods and Services
- Kubernetes cluster: A set of worker machines that run containerized applications
- Node: A worker machine
  + Every cluster has at least one worker node
  + A containerized application deployed on a worker node
  + A worker node provides CPU, memory, storage and netowrk resources so that containers can be excuted and connected to the network
  + Control plane: A container orchestration layer which defines, deploys and manages container lifecycles through APIs and Interfaces
- Kubernetes can manage various objects
  + Pod: The smallest deployment unit including one or more containers
  + 배포: 배포 객체를 통해 원하는 배포 상태를 쿠버네티스에 전달하며, 각 인스턴스에 대해 파드를 만들고 잘 작동하도록 관리, 여러 개의 파드를 하나의 집합체로 관리 가능
  + Deployment: Declare the desired deployment state to kubernetes, creates pods for each instance, ensures they run properly, manages multiple Pods as a single unit
  + Service: Exposes deployments to other nodes within the cluster or externally and distributes load evenly across pod instances
- Resource manifest: A file that describe sdesired state of an application(e.g. Replicate 5 instances, expose via 8080 port)

