# Cloud Native Spring in Action
## 2. Cloud Native pattern and technology
### 2.1) Cloud native development Principles: 12-Factor App and Beyond
- The Twelve-Factor App methodology for designing and building cloud native applications, proposed by Heroku cloud platform engineers
    + suitable for deployment on cloud platforms
    + Designed with scalability in mind
    + Applicable to various systems
    + supports continuous deployment and agility
- The Fiftenn-Factor App methodology presented in Kevin Hoffman's Beyond the Twelve-Facotr-App
##### 2.1.1) One codebase, One application
- Establishes a one-to-one relationship between the application and its codebase
- Shared code should be mained in a seperate codebase and support other applications either as a dependency library or as an independently executable service
- A Deployment is a ruuning instance of application, which can be deployed to different environments and the application artifacts excuted on each envrionment are identical
#### 2.1.2) API First
- Using an API First approach enables designing systems suitable for distributed architectures and distributing work accross different teams
#### 2.1.3) Dependency management
- All dependency libraries must be explicitly declared, enabling dependency library management tools to download them from a central repository
- The only dependencies application can implicitly assume will be available in its runtime envrionments are the language runtime and dependency management tools
#### 2.1.4) Design, Build, Release, Run
- Design: Determin the technologies, dependencies and tools required for specific application features
- Build: Compile the codebase and package it with dependency libraries to create an immutable artifact called build, which must be uniquely identifiable
- Release: Compile the build with environment specific configuration, Each release must be immutable and uniquely identifiable using versioning scheme such as semantic versioning or timestamps
- Run: Excute a specific release of the application in the runtime environment
#### 2.1.5) Configuration , credentials and Code
- Configuration refers to anything may vary between deployments. When configuration needs to change, it should be to do so without modifying code or rebuilding the application
- Examples include resource information for Backend services such as databases or messaging systems and credentials for accessing third-party APIs and feature flags.
#### 2.1.6) log
- Applications treat logs as time-ordered event streams and write them to standard output
- Logs can be collected and inspected using external tools such as log aggregators
#### 2.1.7) Disposability
- The case when applications can be initialized and stopped anytime refers this application is disposable
- When an application can be started or stopped at any time, It is referred to as "disposable"
#### 2.1.8) Backing Service
- Backing services can be defined as external resources that an application uses to provide its functionality
#### 2.1.9) Environment Parity
- Keep all environments as similar as possible
    + Time gap: Minimize the time between writing code and deploying to production through automation and continuous deployment
    + Personnel gap: Close the gap between developers who build applications and operators who manage production deployments by implementing the DevOps philosophy "You build it, You run it"
    + Tools gap: Use the same types and versions of backing services across all environments
#### 2.1.10) Admin processes
- 관리 작업 역시 코드의 형태로 형상 관리 시스템을 통해 관리하면서 지원의 대상이 되는 애플리케이션과 함께 제공해서 애플리케이션과 동일한 환경에서 실행해야 한다.
#### 2.1.11) 포트 바인딩
- 애플리케이션은 독립적이어야 하고 포트 바인딩을 통해 서비스를 제공해야 한다.
- 애플리케이션이 제공하는 서비스는 포트 바인딩을 통해 외부로 노출된다.
#### 2.1.12) 상태를 갖지 않는 프로세스
- 상태를 갖지 않는 애플리케이션은 상태의 관리 및 저장을 지원 서비스에 위임하게 된다.
#### 2.1.13) 동시성
- 애플리케이션이 상태를 갖지 않을 때만 동시 처리가 가능해진다.
- 애플리케이션은 동시성을 통해 많은 사용자에게 서비스를 제공할 수 있어야 한다.
#### 2.1.14) 원격 측정
- 시스템의 작동을 원격으로 모니터링할 수 있도록 모든 구성 요소가 올바른 데이터를 제공하는 것이다.
- 애플리케이션을 우주 탐사선으로 비유하는 매우 매력적인 이미지를 통해 호프만은 중요성을 강조하고 있다.
- 원격으로 애플리케이션을 모니터링하고 제어하려면 어떤 종류의 원격 측정이 필요할까?
#### 2.1.15) 인증 및 승인
- 제롵트러스트 접근법에 따라 시스템 내 상호작용의 안전성은 모든 설계적, 인프라적 수준에서 확보되어야 한다.
- 인증을 통해 누가 애플리케이션을 사용하고 있는 지 추적할 수 있다.
### 2.3) 도커를 통한 애플리케이션 컨테이너화
#### 2.3.1) 도커 소개: 이미지 및 컨테이너
- 도커 서버: 도커의 핵심 작업을 수행하는 프로세스(dockerd)
- 도커 데몬: 백그라운드에서 실행되면서 이미지, 컨테이너, 볼륨, 네트워크 같은 도커 객체를 만들고 관리한다.
- 도커 호스트: 도커 서버가 실행되는 컴퓨터
- 도커 클라이언트: 도커 데몬이 제공하는 API와 상호 작용하는 인터페이스
- 컨테이너 저장소: 컨테이너 이미지를 저장하고 공유하는 서비스
- 컨테이너 이미지: 내부에서 애플리케이션을 실행하는 데 필요한 모든 것을 포함하는 실행 가능한 경량의 패키지
- 컨테이너: 컨테이너 이미지의 실행 가능한 인스턴스
#### 2.4.1) 쿠버네티스 소개: 배포, 파드, 서비스
- 쿠버네티스 클러스터: 컨테이너화된 애플리케이션을 실행하는 작업자 머신의 집합
- 노드: 작업자 머신
  + 모든 클러스터에는 적어도 하나의 작업자 노드가 존재
  + 작업자 노드에 컨테이너화된 애플리케이션 배포
  + 작업자노드는 CPU, 메모리, 스토리지, 네트워크 등을 제공하여 컨테이너가 실행되고 네트워크에 연결 가능
  + 컨트롤 플레인: 작업자 노드를 관리하는 컨테이너 오케스트레이션 계층이며, API 및 인터페이스를 통해 컨테이너의 라이프사이클을 정의, 배포, 관리한다.
- 쿠버네티스는 다양한 객체를 관리 가능
  + 파드: 가장 작은 배포 단위로 하나 이상의 컨테이너 포함
  + 배포: 배포 객체를 통해 원하는 배포 상태를 쿠버네티스에 전달하며, 각 인스턴스에 대해 파드를 만들고 잘 작동하도록 관리, 여러 개의 파드를 하나의 집합체로 관리 가능
  + 서비스: 서비스 정의를 통해 배포는 클러스터 내의 다른 노드나 왜부로 노출되며 파드 인스턴스들이 균일한 부하를 갖도록 관리
- 리소스 매니페스트: 애플리케이션에 대해 원하는 상태를 기술하는 파일이며(예: 5개를 복제하여 8080 포트를 통해 외부로 노출되어야 한다)
