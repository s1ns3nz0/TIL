# Cloud Native Spring in Action
## 2. 클라우드 네이티브 패턴 및 기술
### 2.1) 클라우드 네이티브 개발 원칙: 12요소와 확장
- 히로쿠 클라우드 플랫폼 엔지니어들이 제안한 클라우드 네이티브 어플리케이션 설계 및 구축을 위한 12요소 방법론
    + 클라우드 플랫폼에 배포하기에 적합
    + 확장을 염두에 둔 설계
    + 다양한 시스템에 적용 가능
    + 지속적 배포 및 민첩성을 지원
- 케빈 호프만의 <<Beyond the Twelve-Factor App>>에 제시된 15요소 방법론
##### 2.1.1) 하나의 코드베이스, 하나의 애플리케이션
- 애플리케이션과 코드베이스 사이의 일대일 관계를 설정한다.
- 공유 코드는 별도의 코드베이스로 유지되면서 의존성 라이브러리로 포함되든지 아니면 독자적으로 실행될 수 있는 서비스로 다른 애플리케이션을 지원해야 한다.
- 베포는 애플리케이션의 실행 인스턴스이며 서로 다른 환경으로의 배포가 가능하고 각 환경에서 실행되는 애플리케이션 아티팩트는 동일하다.
#### 2.1.2) API 우선
- API 우선 접근 방식을 사용하면 분산 시스템에 적합하도록 시스템을 고려하고 서로 다른 팀 간의 업무를 배분할 수 있다.
#### 2.1.3) 의존성 관리
- 애플리케이션의 모든 의존 라이브러리는 명시적인 방식으로 선언되어야 하며 이를 통해 의존 라이브러리르 관리 툴이 중앙 저장소에서 다운로드할 수 있어야 한다.
- 애플리케이션이 자신의 환경에서 제공받을 것이라고 암묵적으로 가정하는 의존성은 언어 런타임과 의존성 관리 툴밖에 없다.
#### 2.1.4) 설계, 빌드, 릴리스, 실행
- 설계 단계: 특정 애플리케이션 기능에 필요한 기술, 의존성 및 툴이 결정된다.
- 빌드 단계: 코드베이스를 컴파일하고 의존 라이브러리와 함께 패키지로 만들어 빌드라고 부르는 불가변 아티팩트를 생성하며 이 빌드 아티팩트는 고유하게 식별 가능해야 한다.
- 릴리스 단계: 배포하기 위해 빌드를 특정 설정과 결합하며, 각 릴리즈는 변경할 수 없으며 버전 관리 방식에 따라 예를 들어 시맨틱 버저닝 또는 타임스탬프를 사용해 고유하게 식별할 수 있어야 한다.
- 실행 단계: 애플리케이션의 특정 릴리즈가 실행 환경에서 작동한다.
#### 2.1.5) 설정, 크리덴셜 및 코드
- 설정이란 배포 사이에 변경될 가능성이 있는 모든것이며, 애플리케이션의 설정을 변경해야 한다면 코드의 변경이나 애플리케이션의 재빌드 없이도 그렇게 할 수 있어야 한다.
- 데이터베이스 또는 메시징 시스템과 같은 백엔드 서비스에 대한 리소스 정보, 타사 API에 액세스 할 수 있는 유저 정보 및 기능 플래그를 들 수 있다.
#### 2.1.6) 로그
- 애플리케이션은 로그를 시간 순서대로 생성되는 이벤트로 처리해 표준 출력에 기록한다.
- 로그 수집기와 같은 외부 툴을 사용하여 로그를 수집하고 검사할 수 있다.
#### 2.1.7) 일회성
- 언제라도 애플리케이션을 시작하거나 중지할 수 있는 경우를 일컬어 '이 애플리케이션은 일회성이다'라고 한다.
#### 2.1.8) 지원 서비스
- 지원서비스는 어떤 애플리케이션이 자신의 기능을 제공하기 위해 사용하는 외부 리소스로 정의할 수 있다.
#### 2.1.9) 환경 동일성
- 모든 환경을 가능한 한 비슷하게 유지하는 것이다.
    + 시간 차이: 자동화 및 지속적 배포를 통해서 개발자가 코드를 작성한 이후부터 프로덕션을 배포할 때까지의 기간을 줄이기 위해 노력한다.
    + 사람 차이: 개발자는 애플리케이션을 만들고 운영자는 프로덕션에서 배포를 관리한다. '만든 사람이 실행한다.'라는 DevOps의 철학을 실현함으로써 해결할 수 있다.
    + 도구 차이: 모든 환경에서 동일한 유혀오가 동일한 버전의 지원 서비스를 사용해야 한다.
#### 2.1.10) 관리 프로세스
- 관리 작업 역시 코드의 형태로 형상 관리 시스템을 통해 관리하면서 지원의 대상이 되는 애플리케이션과 함께 제공해서 애플리케이션과 동일한 환경에서 실행해야 한다.
#### 2.1.11) 포트 바인딩
- 애플리케이션은 독립적이어야 하고 포트 바인딩을 통해 서비스를 제공해야 한다.
- 애플리케이션이 제공하는 서비스는 포트 바인딩을 통해 외부로 노출된다.
#### 2.1.12) 상태를 갖지 않는 프로세스
- 상태를 갖지 않는 애플리케이션은 상태의 관리 및 저장을 지원 서비스에 위임하게 된다.
#### 2.1.13) 동시성
- 애플리케이션이 상태를 갖지 않을 때만 동시 처리가 가능해진다.
- 애플리케이션은 동시성을 통해 많은 사용자에게 서비스를 제공할 수 있어야 한다.
#### 2.1.14) 원격 측정
- 시스템의 작동을 원격으로 모니터링할 수 있도록 모든 구성 요소가 올바른 데이터를 제공하는 것이다.
- 애플리케이션을 우주 탐사선으로 비유하는 매우 매력적인 이미지를 통해 호프만은 중요성을 강조하고 있다.
- 원격으로 애플리케이션을 모니터링하고 제어하려면 어떤 종류의 원격 측정이 필요할까?
#### 2.1.15) 인증 및 승인
- 제롵트러스트 접근법에 따라 시스템 내 상호작용의 안전성은 모든 설계적, 인프라적 수준에서 확보되어야 한다.
- 인증을 통해 누가 애플리케이션을 사용하고 있는 지 추적할 수 있다.
### 2.3) 도커를 통한 애플리케이션 컨테이너화
#### 2.3.1) 도커 소개: 이미지 및 컨테이너
- 도커 서버: 도커의 핵심 작업을 수행하는 프로세스(dockerd)
- 도커 데몬: 백그라운드에서 실행되면서 이미지, 컨테이너, 볼륨, 네트워크 같은 도커 객체를 만들고 관리한다.
- 도커 호스트: 도커 서버가 실행되는 컴퓨터
- 도커 클라이언트: 도커 데몬이 제공하는 API와 상호 작용하는 인터페이스
- 컨테이너 저장소: 컨테이너 이미지를 저장하고 공유하는 서비스
- 컨테이너 이미지: 내부에서 애플리케이션을 실행하는 데 필요한 모든 것을 포함하는 실행 가능한 경량의 패키지
- 컨테이너: 컨테이너 이미지의 실행 가능한 인스턴스
#### 2.4.1) 쿠버네티스 소개: 배포, 파드, 서비스
- 쿠버네티스 클러스터: 컨테이너화된 애플리케이션을 실행하는 작업자 머신의 집합
- 노드: 작업자 머신
  + 모든 클러스터에는 적어도 하나의 작업자 노드가 존재
  + 작업자 노드에 컨테이너화된 애플리케이션 배포
  + 작업자노드는 CPU, 메모리, 스토리지, 네트워크 등을 제공하여 컨테이너가 실행되고 네트워크에 연결 가능
  + 컨트롤 플레인: 작업자 노드를 관리하는 컨테이너 오케스트레이션 계층이며, API 및 인터페이스를 통해 컨테이너의 라이프사이클을 정의, 배포, 관리한다.
- 쿠버네티스는 다양한 객체를 관리 가능
  + 파드: 가장 작은 배포 단위로 하나 이상의 컨테이너 포함
  + 배포: 배포 객체를 통해 원하는 배포 상태를 쿠버네티스에 전달하며, 각 인스턴스에 대해 파드를 만들고 잘 작동하도록 관리, 여러 개의 파드를 하나의 집합체로 관리 가능
  + 서비스: 서비스 정의를 통해 배포는 클러스터 내의 다른 노드나 왜부로 노출되며 파드 인스턴스들이 균일한 부하를 갖도록 관리
- 리소스 매니페스트: 애플리케이션에 대해 원하는 상태를 기술하는 파일이며(예: 5개를 복제하여 8080 포트를 통해 외부로 노출되어야 한다)
