# Cloud Native Spring in Action
## 1. Cloud Native Fundamentals
### 1.5) Is the cloud the best practice?
- If you don't have the problems cloud-native addresses and those properties, cloud native may not be the optimal solution
- The key is to determine whether specific technologies and approaches can address the problems
- The key goals for adopting cloud native are speed, scalability, resilience and cost optimization.
- Speed(more fater and re deployment), Resilience(reliability and stability), 
#### 1.5.1) Speed
- More faster and frequent release makes competition, customer due date and feedback period more shorter 
- Faster and more frequent releases not only help meet competitive pressures, customer deadlines but also shorten feedback cycle 
- Shorter feedback loops reduce the risks associated with new features
#### 1.5.2) Resilience
- Cloud native applications must be resilient, and Cloud computing enables building strategies to implement resilient infrastructure
- Cloud native can be an excellet choice when business requirements demand high availability, scalability and resilience
#### 1.5.3) Scalability
- Scalability means softeware can scale based on demand
- Must scale dynamically based on demand
- For businesses requiring rapid adaptation to new customers or flexible support for diverse client types, highly scalable cloud native applications integrated with cloud computing ensure necessary elasticity.
#### 1.5.4) Costs
- Infrastructures running on 24/7 is no longer necessary 
- Create only the necessary resources, pay only for actual usage, and release resources that are not longer needed
### 1.6) Cloud native composition
- Specific technologies or architectures are mentiond only as example
#### 1.6.1) Container
- Before containers, virtual machines were relied upon for environment provision, isolation and configuration
- OS containers are lightweight, executable file package that contains everything need to run an application
- Containers share the kernel with the host
- On linux, This is achieved by leveraging several features provided by the linux kernel
  + Namespace: 각 프로세스(또는 프로세스 그룹)가 시스템에서 사용할 수 있는 리소스를 일부만 볼 수 있도록 하기 위해 프로세스 간 리소스를 분할
  + Namespace: Allocate resources for each processes(or process groups) to monitor a part of usable resources in system
  + Namespace: Partitions resources between processes so that each process (or process groups) can see only a subset of available system resources
  + cgroup: Controls and limits resource usage for processes
- Containers can run reliably across almost any computing environment regardless of the applications, dependencies or middlware they contain
#### 1.6.2) Orchestration
- 단일 서버에서 컨테이너를 생성하고 관리하는 것은 간단하지만 수십 또는 수백 개의 컨테이너를 여러 대의 서버에 배포하고 처리하려면 또 다른 무엇인가가 필요하다.
- 컨테이너 오케스트레이션은 다음과 같은 다양한 작업을 자동화하는 데 도움이 된다.
  + 클러스터 관리로서 필요한 경우 머신을 생성하거나 삭제할 수 있다.
  + 컨테이너가 서로 통신하도록 네트워크를 설정하고 라우팅, 서비스 검색 및 로드 밸런싱을 정의한다.
  + 인터넷에 서비스 노출, 포트 및 네트워크를 구축한다.
  + 특정 기준에 따라 컨테이너에 자원을 할당한다.
  + 보안 및 액세스 제어 정책을 시행한다.
- 오케스트레이션 튤에 대한 명령은 선언적으로 이루어지는데, YAML 파일을 통해 수행된다.
- 보통은 특정 툴이 원하는 형식과 언어를 사용해 달성하고자 하는 상태를 기술한다.
#### 1.6.3) 서버리스
- 클라우드 서비스가 제공하는 추상화 계층을 한층 더 늘려 서버리스 기술을 사용할 수 있다.
- 개발자는 애플리케이션에 대한 비즈니스 로직을 구현하는 데만 집중할 수 있다.
- 서버리스 플랫폼은 가상 시스템, 컨테이너 및 동적 확장을 포함하여 실행할 애플리케이션에 필요한 모든 인프라 작업을 플랫폼이 대신 처리해준다.
- 서비스형 백엔드(Backend as a service, BaaS)
  + 클라우드 공급자가 제공하는 타사 서비스에 크게 의존하는 애플리케이션을 의미하며, 데이터베이스, 인증 서비스, 메시지 큐와 같은 것들이 해당
  + 옥타, 구글 파이어베이스, 아마존 API Gateway
- 서비스형 함수(Function as a service, FaaS)
  + 상태가 없고 이벤트에 의해 실행되며 플랫폼이 전적으로 관리하는 애플리케이션을 의미한다.
  + 애플리케이션의 오케스트레이션 및 확장과 관련된 배포 및 운영 비용을 줄이는 데 중점을 둔다.
  + 아마존 람다, 구글 클라우드 함수, 케이네이티브, 아파치 오픈휘스크
  + 서버리스 모델에서는 필요한 경우에만 리소스가 제공되며 처리할 것이 없으면 모든 것이 중단된다. 이것이 바로 서버리스 플랫폼이 제공하는 주요 기능 중 하나인 제로 스케일링이다.
### 1.7) 클라우드 네이티브 애플리케이션을 위한 아키텍처
- 클라우드 네이티브 아키텍쳐 요소
  + 상호작용: HTTP, RSocket, gRPC 메시징과 같은 서비스 간 통신
  + 데이터 서비스: 데이터베이스, 메시징 시스템 및 상태를 유지하는 그 밖의 구성 요소
  + 애플리케이션 서비스: 느슨히 결합되고, 상태를 유지하지 않고 독립적으로 배포할 수 있는 단위
#### 1.7.2) 클라우드 네이티브 애플리케이션을 위한 서비스 기반 아키텍처
- 서비스: 다른 구성 요소에 어떤 종류의 서비스를 제공하는 구성 요소
  + 애플리케이션 서비스: 상태를 갖지 않으며 모든 종류의 논리를 구현한다.
  + 데이터 서비스: 상태 저장이 가능하며 모든 종류의 상태를 저장한다. 이 때 상태란, 서비스를 종료하고 새로운 인스턴스를 생성해야 할 경우 서비스 종료 전에 저장되어야 하는 모든 것이다.
- 상호작용: 시스템의 요구 사항을 충족시키기 위해 수행되는 서비스 간 통신
  + 
