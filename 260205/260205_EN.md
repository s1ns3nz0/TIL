# Cloud Native Spring in Action
## 1. Cloud Native Fundamentals
### 1.5) Is the cloud the best practice?
- If you don't have the problems cloud-native addresses and those properties, cloud native may not be the optimal solution
- The key is to determine whether specific technologies and approaches can address the problems
- The key goals for adopting cloud native are speed, scalability, resilience and cost optimization.
- Speed(more fater and re deployment), Resilience(reliability and stability), 
#### 1.5.1) Speed
- More faster and frequent release makes competition, customer due date and feedback period more shorter 
- Faster and more frequent releases not only help meet competitive pressures, customer deadlines but also shorten feedback cycle 
- Shorter feedback loops reduce the risks associated with new features
#### 1.5.2) Resilience
- Cloud native applications must be resilient, and Cloud computing enables building strategies to implement resilient infrastructure
- Cloud native can be an excellet choice when business requirements demand high availability, scalability and resilience
#### 1.5.3) Scalability
- Scalability means softeware can scale based on demand
- Must scale dynamically based on demand
- For businesses requiring rapid adaptation to new customers or flexible support for diverse client types, highly scalable cloud native applications integrated with cloud computing ensure necessary elasticity.
#### 1.5.4) Costs
- Infrastructures running on 24/7 is no longer necessary 
- Create only the necessary resources, pay only for actual usage, and release resources that are not longer needed
### 1.6) Cloud native composition
- Specific technologies or architectures are mentiond only as example
#### 1.6.1) Container
- Before containers, virtual machines were relied upon for environment provision, isolation and configuration
- OS containers are lightweight, executable file package that contains everything need to run an application
- Containers share the kernel with the host
- On linux, This is achieved by leveraging several features provided by the linux kernel
  + Namespace: 각 프로세스(또는 프로세스 그룹)가 시스템에서 사용할 수 있는 리소스를 일부만 볼 수 있도록 하기 위해 프로세스 간 리소스를 분할
  + Namespace: Allocate resources for each processes(or process groups) to monitor a part of usable resources in system
  + Namespace: Partitions resources between processes so that each process (or process groups) can see only a subset of available system resources
  + cgroup: Controls and limits resource usage for processes
- Containers can run reliably across almost any computing environment regardless of the applications, dependencies or middlware they contain
#### 1.6.2) Orchestration
- While provisioining and managing containers on a single server is simple, scaling to tens or hundreds of containers across multiple servers demands orchestration tools.
- Container orchestration helps automate the following tasks:
  + Provision and terminate machines as needed for cluster management
  + Configure networking to enable container communication and define routing, service discovery and load balancing
  + Service exposure to Internet, Implement ports and networking
  + Expose services to the Internet and configure ports and networking
  + Allocate resources to containers based on defined criteria
  + Enforce security and access control policies
- Commands for orchestration tools are issued declaratively through YAML files
- Typically, The desired state is described using the specific format and language required by each tool
#### 1.6.3) Serverless
- Serverless technologies can be used by adding another layer of abstraction on top of cloud services
- Developers can focus solely on implementing business log for their applications
- Serverless platforms handle all necessary infrastructure task including virtual machines, container and dynamic scaling for running application eliminiating the need for management
- Backend as a service, BaaS
  + Referes to applications that heavily rely on third-party services provided by cloud service providers, such as databases, authentication services and message queues
  + Okta, Googl Firebase, Amazon API Gateway
- Function as a service, FaaS
  + Refers to applications that are stateless, event-driven and fully managed by the platform
  + Focus on reducing operation costs of deployment and operation related to application's orchestration or scalability
  + Focuses on reducing deployment and operational costs associated with application orchestration and scaling
  + Amazon lambda, GCP funciton
  + In the serverless model, resources are provisioned only when needed, and everything shuts down when there is nothing to process
  + This is known as scale-to-zero, one of the key features provided by serverless platforms
### 1.7) Architecture for cloud native applications
- Componenets of cloud native architecture
  + Interaction: Communication between services using protocols such as HTTP, RSocket, gRPC messaging
  + 데이터 서비스: 데이터베이스, 메시징 시스템 및 상태를 유지하는 그 밖의 구성 요소
  + Data Services: Other components for database, meesaging system or state
  + Data Services: Databases, messaging systems, and other components that maintain state
  + Application Services: Loosely coupled, stateless and independently deployable units
#### 1.7.2) Service based architecture for cloud native applications
- Service: A component that provides some kind of service to other components
  + 애플리케이션 서비스: 상태를 갖지 않으며 모든 종류의 논리를 구현한다.
  + Application service: stateless, implementing all kinds of logics
  + Application service: stateless componenets that implement various types of business logic
  + Data service: stateful componenets that store all types of state. State referes to any data that must be persisted before terminating a service instance and creating a new one
- Interaction: Communication between services to fulfill system requirements
