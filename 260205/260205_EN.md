# Cloud Native Spring in Action
## 1. Cloud Native Fundamentals
### 1.5) Is the cloud the best practice?
- If you don't have the problems cloud-native addresses and those properties, cloud native may not be the optimal solution
- The key is to determine whether specific technologies and approaches can address the problems
- The key goals for adopting cloud native are speed, scalability, resilience and cost optimization.
- Speed(more fater and re deployment), Resilience(reliability and stability), 
#### 1.5.1) Speed
- More faster and frequent release makes competition, customer due date and feedback period more shorter 
- Faster and more frequent releases not only help meet competitive pressures, customer deadlines but also shorten feedback cycle 
- Shorter feedback loops reduce the risks associated with new features
#### 1.5.2) Resilience
- Cloud native applications must be resilient, and Cloud computing enables building strategies to implement resilient infrastructure
- Cloud native can be an excellet choice when business requirements demand high availability, scalability and resilience
#### 1.5.3) Scalability
- Scalability means softeware can scale based on demand
- Must scale dynamically based on demand
- For businesses requiring rapid adaptation to new customers or flexible support for diverse client types, highly scalable cloud native applications integrated with cloud computing ensure necessary elasticity.
#### 1.5.4) Costs
- Infrastructures running on 24/7 is no longer necessary 
- Create only the necessary resources, pay only for actual usage, and release resources that are not longer needed
### 1.6) Cloud native composition
- Specific technologies or architectures are mentiond only as example
#### 1.6.1) Container
- Before containers, virtual machines were relied upon for environment provision, isolation and configuration
- OS containers are lightweight, executable file package that contains everything need to run an application
- Containers share the kernel with the host
- On linux, This is achieved by leveraging several features provided by the linux kernel
  + Namespace: 각 프로세스(또는 프로세스 그룹)가 시스템에서 사용할 수 있는 리소스를 일부만 볼 수 있도록 하기 위해 프로세스 간 리소스를 분할
  + Namespace: Allocate resources for each processes(or process groups) to monitor a part of usable resources in system
  + Namespace: Partitions resources between processes so that each process (or process groups) can see only a subset of available system resources
  + cgroup: Controls and limits resource usage for processes
- Containers can run reliably across almost any computing environment regardless of the applications, dependencies or middlware they contain
#### 1.6.2) Orchestration
- While provisioining and managing containers on a single server is simple, scaling to tens or hundreds of containers across multiple servers demands orchestration tools.
- Container orchestration helps automate the following tasks:
  + Provision and terminate machines as needed for cluster management
  + Configure networking to enable container communication and define routing, service discovery and load balancing
  + Service exposure to Internet, Implement ports and networking
  + Expose services to the Internet and configure ports and networking
  + Allocate resources to containers based on defined criteria
  + Enforce security and access control policies
- Commands for orchestration tools are issued declaratively through YAML files
- Typically, The desired state is described using the specific format and language required by each tool
#### 1.6.3) Serverless
- Serverless technologies can be used by adding another layer of abstraction on top of cloud services
- Developers can focus solely on implementing business log for their applications
- 서버리스 플랫폼은 가상 시스템, 컨테이너 및 동적 확장을 포함하여 실행할 애플리케이션에 필요한 모든 인프라 작업을 플랫폼이 대신 처리해준다.
- Serverless ploatform process all needed infrastructure tasks including virtual system, containers and dynamic extension for an application to run instead
- Serverless platforms handle all necessary infrastructure task including virtual machines, container and dynamic scaling for running application eliminiating the need for management
- 서비스형 백엔드(Backend as a service, BaaS)
  + 클라우드 공급자가 제공하는 타사 서비스에 크게 의존하는 애플리케이션을 의미하며, 데이터베이스, 인증 서비스, 메시지 큐와 같은 것들이 해당
  + 옥타, 구글 파이어베이스, 아마존 API Gateway
- 서비스형 함수(Function as a service, FaaS)
  + 상태가 없고 이벤트에 의해 실행되며 플랫폼이 전적으로 관리하는 애플리케이션을 의미한다.
  + 애플리케이션의 오케스트레이션 및 확장과 관련된 배포 및 운영 비용을 줄이는 데 중점을 둔다.
  + 아마존 람다, 구글 클라우드 함수, 케이네이티브, 아파치 오픈휘스크
  + 서버리스 모델에서는 필요한 경우에만 리소스가 제공되며 처리할 것이 없으면 모든 것이 중단된다. 이것이 바로 서버리스 플랫폼이 제공하는 주요 기능 중 하나인 제로 스케일링이다.
### 1.7) 클라우드 네이티브 애플리케이션을 위한 아키텍처
- 클라우드 네이티브 아키텍쳐 요소
  + 상호작용: HTTP, RSocket, gRPC 메시징과 같은 서비스 간 통신
  + 데이터 서비스: 데이터베이스, 메시징 시스템 및 상태를 유지하는 그 밖의 구성 요소
  + 애플리케이션 서비스: 느슨히 결합되고, 상태를 유지하지 않고 독립적으로 배포할 수 있는 단위
#### 1.7.2) 클라우드 네이티브 애플리케이션을 위한 서비스 기반 아키텍처
- 서비스: 다른 구성 요소에 어떤 종류의 서비스를 제공하는 구성 요소
  + 애플리케이션 서비스: 상태를 갖지 않으며 모든 종류의 논리를 구현한다.
  + 데이터 서비스: 상태 저장이 가능하며 모든 종류의 상태를 저장한다. 이 때 상태란, 서비스를 종료하고 새로운 인스턴스를 생성해야 할 경우 서비스 종료 전에 저장되어야 하는 모든 것이다.
- 상호작용: 시스템의 요구 사항을 충족시키기 위해 수행되는 서비스 간 통신
  + 
